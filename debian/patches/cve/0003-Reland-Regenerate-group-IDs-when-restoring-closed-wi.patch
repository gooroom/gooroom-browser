From cfb7a2301c0c48dc277beac4821904149aab8137 Mon Sep 17 00:00:00 2001
From: Collin Baker <collinbaker@chromium.org>
Date: Tue, 22 Jun 2021 13:47:45 +0000
Subject: [PATCH 03/21] Reland "Regenerate group IDs when restoring closed
 window"

This is a reland of b21775d121bda1fb5084487547a63dccb5429b74

Changes from original:

Fixes crash caused by tab group IDs referenced by individual Tab
objects in TabRestoreService, but not listed in the Window's tab
groups.

Adds group ID regeneration to session restore to prevent bad
interaction betwee nsession restore and tab restore.

Original change's description:
> Regenerate group IDs when restoring closed window
>
> As currently designed, tabs and windows can be restored in ways that
> split the same group ID across multiple windows. For example,
> restoring the same window twice, or restoring a tab from a group then
> a window with the same group
>
> Regenerating group IDs when restoring a window solves this
> problem. When restoring a tab, it is always put into its group if it's
> open in any window.
>
> Bug: 1202102
> Change-Id: Id07cd92f87fd48f019e38993322d4a335f2a3801
> Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2911467
> Commit-Queue: Collin Baker <collinbaker@chromium.org>
> Reviewed-by: Scott Violet <sky@chromium.org>
> Reviewed-by: Charlene Yan <cyan@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#887307}

(cherry picked from commit cbe2ec51f6607fc4891bf1d44392d8264c29ab2f)

(cherry picked from commit 6a55e7b2ea6dae726430626cc7cf85517f6268b0)

Bug: 1202102, 1214197
Change-Id: Ibc6df547160e5ad23cf4f69ec5bca8329b728497
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2928804
Auto-Submit: Collin Baker <collinbaker@chromium.org>
Commit-Queue: Scott Violet <sky@chromium.org>
Reviewed-by: Scott Violet <sky@chromium.org>
Cr-Original-Original-Commit-Position: refs/heads/master@{#888641}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2965641
Auto-Submit: Emily Shack <emshack@chromium.org>
Cr-Original-Commit-Position: refs/branch-heads/4472@{#1490}
Cr-Original-Branched-From: 3d60439cfb36485e76a1c5bb7f513d3721b20da1-refs/heads/master@{#870763}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2975454
Reviewed-by: Victor-Gabriel Savu <vsavu@google.com>
Reviewed-by: Jana Grill <janagrill@google.com>
Commit-Queue: Artem Sumaneev <asumaneev@google.com>
Owners-Override: Artem Sumaneev <asumaneev@google.com>
Cr-Commit-Position: refs/branch-heads/4430@{#1534}
Cr-Branched-From: e5ce7dc4f7518237b3d9bb93cccca35d25216cbe-refs/heads/master@{#857950}
---
 chrome/browser/sessions/session_restore.cc    | 55 +++++++++++----
 .../sessions/session_restore_browsertest.cc   | 46 ++++++++++++-
 .../sessions/tab_restore_browsertest.cc       | 69 ++++++++++++++++---
 .../core/tab_restore_service_helper.cc        | 30 +++++++-
 4 files changed, 170 insertions(+), 30 deletions(-)

diff --git a/chrome/browser/sessions/session_restore.cc b/chrome/browser/sessions/session_restore.cc
index 263b17357..ef08681fa 100644
--- a/chrome/browser/sessions/session_restore.cc
+++ b/chrome/browser/sessions/session_restore.cc
@@ -16,6 +16,7 @@
 #include "base/callback.h"
 #include "base/callback_helpers.h"
 #include "base/command_line.h"
+#include "base/containers/flat_map.h"
 #include "base/debug/alias.h"
 #include "base/feature_list.h"
 #include "base/location.h"
@@ -188,10 +189,15 @@ class SessionRestoreImpl : public BrowserListObserver {
           (*i)->user_title, (*i)->window_id.id());
       browsers.push_back(browser);
 
+      // A foreign session window will not contain tab groups, however an
+      // instance is still required for RestoreTabsToBrowser.
+      base::flat_map<tab_groups::TabGroupId, tab_groups::TabGroupId>
+          new_group_ids;
+
       // Restore and show the browser.
       const int initial_tab_count = 0;
-      RestoreTabsToBrowser(*(*i), browser, initial_tab_count,
-                           &created_contents);
+      RestoreTabsToBrowser(*(*i), browser, initial_tab_count, &created_contents,
+                           &new_group_ids);
       NotifySessionServiceOfRestoredTabs(browser, initial_tab_count);
     }
 
@@ -463,9 +469,13 @@ class SessionRestoreImpl : public BrowserListObserver {
 
       // 5. Restore tabs in |browser|. This will also call Show() on |browser|
       //    if its initial show state is not mimimized.
-      // However, with desks restore enabled, a window is restored to its parent
-      // desk, which can be non-active desk, and left invisible but unminimized.
-      RestoreTabsToBrowser(*(*i), browser, initial_tab_count, created_contents);
+      // For the cases that users have more than one desk, a window is restored
+      // to its parent desk, which can be non-active desk, and left invisible
+      // but unminimized.
+      base::flat_map<tab_groups::TabGroupId, tab_groups::TabGroupId>
+          new_group_ids;
+      RestoreTabsToBrowser(*(*i), browser, initial_tab_count, created_contents,
+                           &new_group_ids);
       (*tab_count) += (static_cast<int>(browser->tab_strip_model()->count()) -
                        initial_tab_count);
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -482,7 +492,7 @@ class SessionRestoreImpl : public BrowserListObserver {
       TabGroupModel* group_model = browser->tab_strip_model()->group_model();
       for (auto& session_tab_group : (*i)->tab_groups) {
         TabGroup* model_tab_group =
-            group_model->GetTabGroup(session_tab_group->id);
+            group_model->GetTabGroup(new_group_ids.at(session_tab_group->id));
         DCHECK(model_tab_group);
         model_tab_group->SetVisualData(session_tab_group->visual_data);
       }
@@ -557,10 +567,13 @@ class SessionRestoreImpl : public BrowserListObserver {
   // tabs but pinned tabs will be pushed in front.
   // If there are no existing tabs, the tab at |window.selected_tab_index| will
   // be selected. Otherwise, the tab selection will remain untouched.
-  void RestoreTabsToBrowser(const sessions::SessionWindow& window,
-                            Browser* browser,
-                            int initial_tab_count,
-                            std::vector<RestoredTab>* created_contents) {
+  void RestoreTabsToBrowser(
+      const sessions::SessionWindow& window,
+      Browser* browser,
+      int initial_tab_count,
+      std::vector<RestoredTab>* created_contents,
+      base::flat_map<tab_groups::TabGroupId, tab_groups::TabGroupId>*
+          new_group_ids) {
     DVLOG(1) << "RestoreTabsToBrowser " << window.tabs.size();
     // TODO(https://crbug.com/1032348): Change to DCHECK once we understand
     // why some browsers don't have an active tab on startup.
@@ -606,8 +619,8 @@ class SessionRestoreImpl : public BrowserListObserver {
       // the existing ones. E.g. this happens in Win8 Metro where we merge
       // windows or when launching a hosted app from the app launcher.
       int tab_index = i + initial_tab_count;
-      RestoreTab(tab, browser, created_contents, tab_index, is_selected_tab,
-                 last_active_time);
+      RestoreTab(tab, browser, created_contents, new_group_ids, tab_index,
+                 is_selected_tab, last_active_time);
     }
   }
 
@@ -619,6 +632,8 @@ class SessionRestoreImpl : public BrowserListObserver {
   void RestoreTab(const sessions::SessionTab& tab,
                   Browser* browser,
                   std::vector<RestoredTab>* created_contents,
+                  base::flat_map<tab_groups::TabGroupId,
+                                 tab_groups::TabGroupId>* new_group_ids,
                   const int tab_index,
                   bool is_selected_tab,
                   base::TimeTicks last_active_time) {
@@ -642,17 +657,29 @@ class SessionRestoreImpl : public BrowserListObserver {
               ->RecreateSessionStorage(tab.session_storage_persistent_id);
     }
 
+    // Relabel group IDs to prevent duplicating groups. See crbug.com/1202102.
+    base::Optional<tab_groups::TabGroupId> new_group;
+    if (tab.group) {
+      auto it = new_group_ids->find(*tab.group);
+      if (it == new_group_ids->end()) {
+        it = new_group_ids
+                 ->emplace(*tab.group, tab_groups::TabGroupId::GenerateNew())
+                 .first;
+      }
+      new_group = it->second;
+    }
+
     // Apply the stored group.
     WebContents* web_contents = chrome::AddRestoredTab(
         browser, tab.navigations, tab_index, selected_index,
-        tab.extension_app_id, tab.group, is_selected_tab, tab.pinned,
+        tab.extension_app_id, new_group, is_selected_tab, tab.pinned,
         last_active_time, session_storage_namespace.get(),
         tab.user_agent_override, true /* from_session_restore */);
     DCHECK(web_contents);
 
     RestoredTab restored_tab(web_contents, is_selected_tab,
                              tab.extension_app_id.empty(), tab.pinned,
-                             tab.group);
+                             new_group);
     created_contents->push_back(restored_tab);
 
     // If this isn't the selected tab, there's nothing else to do.
diff --git a/chrome/browser/sessions/session_restore_browsertest.cc b/chrome/browser/sessions/session_restore_browsertest.cc
index 5dc33e37d..c3c32ba0c 100644
--- a/chrome/browser/sessions/session_restore_browsertest.cc
+++ b/chrome/browser/sessions/session_restore_browsertest.cc
@@ -1025,7 +1025,8 @@ IN_PROC_BROWSER_TEST_P(SessionRestoreTabGroupsTest, TabsWithGroups) {
 
   Browser* new_browser = QuitBrowserAndRestore(browser(), kNumTabs);
   ASSERT_EQ(kNumTabs, new_browser->tab_strip_model()->count());
-  EXPECT_EQ(groups, GetTabGroups(new_browser->tab_strip_model()));
+  ASSERT_NO_FATAL_FAILURE(
+      CheckTabGrouping(new_browser->tab_strip_model(), group_spec));
 }
 
 IN_PROC_BROWSER_TEST_P(SessionRestoreTabGroupsTest, GroupMetadataRestored) {
@@ -1056,11 +1057,19 @@ IN_PROC_BROWSER_TEST_P(SessionRestoreTabGroupsTest, GroupMetadataRestored) {
   TabStripModel* const new_tsm = new_browser->tab_strip_model();
   ASSERT_EQ(5, new_tsm->count());
 
+  const base::Optional<tab_groups::TabGroupId> new_group1 =
+      new_tsm->GetTabGroupForTab(0);
+  const base::Optional<tab_groups::TabGroupId> new_group2 =
+      new_tsm->GetTabGroupForTab(2);
+
+  ASSERT_TRUE(new_group1);
+  ASSERT_TRUE(new_group2);
+
   // Check that the restored visual data is the same.
   const tab_groups::TabGroupVisualData* const group1_restored_data =
-      new_tsm->group_model()->GetTabGroup(group1)->visual_data();
+      new_tsm->group_model()->GetTabGroup(*new_group1)->visual_data();
   const tab_groups::TabGroupVisualData* const group2_restored_data =
-      new_tsm->group_model()->GetTabGroup(group2)->visual_data();
+      new_tsm->group_model()->GetTabGroup(*new_group2)->visual_data();
 
   EXPECT_EQ(group1_data.title(), group1_restored_data->title());
   EXPECT_EQ(group1_data.color(), group1_restored_data->color());
@@ -1070,6 +1079,37 @@ IN_PROC_BROWSER_TEST_P(SessionRestoreTabGroupsTest, GroupMetadataRestored) {
   EXPECT_EQ(group2_data.is_collapsed(), group2_restored_data->is_collapsed());
 }
 
+IN_PROC_BROWSER_TEST_P(SessionRestoreTabGroupsTest,
+                       TabGroupIDsRelabeledOnRestore) {
+  constexpr int kNumTabs = 3;
+  const std::array<base::Optional<int>, kNumTabs> group_spec = {0, 0, 1};
+
+  // Open |kNumTabs| tabs.
+  ui_test_utils::NavigateToURL(browser(), GetUrl1());
+  for (int i = 1; i < kNumTabs; ++i) {
+    ui_test_utils::NavigateToURLWithDisposition(
+        browser(), GetUrl1(), WindowOpenDisposition::NEW_FOREGROUND_TAB,
+        ui_test_utils::BROWSER_TEST_WAIT_FOR_LOAD_STOP);
+  }
+  ASSERT_EQ(kNumTabs, browser()->tab_strip_model()->count());
+
+  CreateTabGroups(browser()->tab_strip_model(), group_spec);
+  ASSERT_NO_FATAL_FAILURE(
+      CheckTabGrouping(browser()->tab_strip_model(), group_spec));
+  const auto orig_groups = GetTabGroups(browser()->tab_strip_model());
+
+  Browser* const new_browser = QuitBrowserAndRestore(browser(), 5);
+  TabStripModel* const new_tsm = new_browser->tab_strip_model();
+  ASSERT_EQ(kNumTabs, new_tsm->count());
+  ASSERT_NO_FATAL_FAILURE(CheckTabGrouping(new_tsm, group_spec));
+  const auto new_groups = GetTabGroups(new_tsm);
+
+  for (int i = 0; i < kNumTabs; ++i) {
+    SCOPED_TRACE(i);
+    EXPECT_NE(orig_groups[i], new_groups[i]);
+  }
+}
+
 INSTANTIATE_TEST_SUITE_P(WithAndWithoutReset,
                          SessionRestoreTabGroupsTest,
                          testing::Values(false, true));
diff --git a/chrome/browser/sessions/tab_restore_browsertest.cc b/chrome/browser/sessions/tab_restore_browsertest.cc
index 6a7ba2efa..5707f7601 100644
--- a/chrome/browser/sessions/tab_restore_browsertest.cc
+++ b/chrome/browser/sessions/tab_restore_browsertest.cc
@@ -1146,20 +1146,23 @@ IN_PROC_BROWSER_TEST_F(TabRestoreTest, RestoreWindowWithGroupedTabs) {
   TabGroupModel* restored_group_model =
       restored_window->tab_strip_model()->group_model();
   ASSERT_EQ(tab_count, restored_window->tab_strip_model()->count());
+  auto restored_group1 =
+      restored_window->tab_strip_model()->GetTabGroupForTab(tab_count - 3);
+  ASSERT_TRUE(restored_group1);
   EXPECT_EQ(
-      base::make_optional(group1),
-      restored_window->tab_strip_model()->GetTabGroupForTab(tab_count - 3));
-  EXPECT_EQ(
-      base::make_optional(group1),
+      restored_window->tab_strip_model()->GetTabGroupForTab(tab_count - 3),
       restored_window->tab_strip_model()->GetTabGroupForTab(tab_count - 2));
-  EXPECT_EQ(
-      base::make_optional(group2),
-      restored_window->tab_strip_model()->GetTabGroupForTab(tab_count - 1));
+  auto restored_group2 =
+      restored_window->tab_strip_model()->GetTabGroupForTab(tab_count - 1);
+  ASSERT_TRUE(restored_group2);
+  EXPECT_NE(restored_group2, restored_group1);
 
-  EXPECT_EQ(group1_data,
-            *restored_group_model->GetTabGroup(group1)->visual_data());
-  EXPECT_EQ(group2_data,
-            *restored_group_model->GetTabGroup(group2)->visual_data());
+  EXPECT_EQ(
+      group1_data,
+      *restored_group_model->GetTabGroup(*restored_group1)->visual_data());
+  EXPECT_EQ(
+      group2_data,
+      *restored_group_model->GetTabGroup(*restored_group2)->visual_data());
 }
 
 // Ensure a tab is not restored between tabs of another group.
@@ -1509,3 +1512,47 @@ IN_PROC_BROWSER_TEST_F(TabRestoreTest, BackToAboutBlank) {
   EXPECT_EQ(initial_origin,
             new_popup->GetMainFrame()->GetLastCommittedOrigin());
 }
+
+// Ensures group IDs are regenerated for restored windows so that we don't split
+// the same group between multiple windows. See https://crbug.com/1202102. This
+// test is temporary until a more comprehensive fix is implemented.
+IN_PROC_BROWSER_TEST_F(TabRestoreTest, RestoredWindowHasNewGroupIds) {
+  sessions::TabRestoreService* service =
+      TabRestoreServiceFactory::GetForProfile(browser()->profile());
+
+  AddSomeTabs(browser(), 2);
+  ASSERT_EQ(3, browser()->tab_strip_model()->count());
+
+  // Create a new browser from which to restore the first.
+  ui_test_utils::NavigateToURLWithDisposition(
+      browser(), GURL(chrome::kChromeUINewTabURL),
+      WindowOpenDisposition::NEW_WINDOW,
+      ui_test_utils::BROWSER_TEST_WAIT_FOR_BROWSER);
+  ASSERT_EQ(2u, active_browser_list_->size());
+  Browser* second_browser = GetBrowser(1);
+  ASSERT_NE(browser(), second_browser);
+
+  auto original_group = browser()->tab_strip_model()->AddToNewGroup({1, 2});
+  CloseBrowserSynchronously(browser());
+  ASSERT_EQ(1u, active_browser_list_->size());
+
+  // We should have a restore entry for the window.
+  const sessions::TabRestoreService::Entries& entries = service->entries();
+  ASSERT_GE(entries.size(), 1u);
+  ASSERT_EQ(entries.front()->type, sessions::TabRestoreService::WINDOW);
+
+  // Restore the window.
+  std::vector<sessions::LiveTab*> restored_window_tabs =
+      service->RestoreEntryById(second_browser->live_tab_context(),
+                                entries.front()->id,
+                                WindowOpenDisposition::NEW_FOREGROUND_TAB);
+  ASSERT_EQ(2u, active_browser_list_->size());
+  ASSERT_EQ(3u, restored_window_tabs.size());
+  Browser* third_browser = GetBrowser(1);
+  ASSERT_NE(second_browser, third_browser);
+  ASSERT_EQ(3, third_browser->tab_strip_model()->count());
+
+  // The group ID should be new.
+  EXPECT_NE(original_group,
+            third_browser->tab_strip_model()->GetTabGroupForTab(1));
+}
diff --git a/components/sessions/core/tab_restore_service_helper.cc b/components/sessions/core/tab_restore_service_helper.cc
index 6395bb9c0..0a87b0630 100644
--- a/components/sessions/core/tab_restore_service_helper.cc
+++ b/components/sessions/core/tab_restore_service_helper.cc
@@ -353,11 +353,36 @@ std::vector<LiveTab*> TabRestoreServiceHelper::RestoreEntryById(
         context = client_->CreateLiveTabContext(
             window.app_name, window.bounds, window.show_state, window.workspace,
             window.user_title);
+
+        base::flat_map<tab_groups::TabGroupId, tab_groups::TabGroupId>
+            new_group_ids;
+
         for (size_t tab_i = 0; tab_i < window.tabs.size(); ++tab_i) {
           const Tab& tab = *window.tabs[tab_i];
+
+          // Relabel group IDs to prevent duplicating groups, e.g. if the same
+          // window is restored twice or a tab of the same ID is restored
+          // elsewhere. See crbug.com/1202102.
+          base::Optional<tab_groups::TabGroupId> new_group;
+          if (tab.group) {
+            auto it = new_group_ids.find(*tab.group);
+            if (it == new_group_ids.end()) {
+              auto new_id = tab_groups::TabGroupId::GenerateNew();
+              // Ensure the new ID does not collide with an existing group,
+              // failing silently if it does. This is extremely unlikely,
+              // given group IDs are 128 bit randomly generated numbers.
+              if (client_->FindLiveTabContextWithGroup(new_id)) {
+                return std::vector<LiveTab*>();
+              }
+              it = new_group_ids.emplace(*tab.group, new_id).first;
+            }
+
+            new_group = it->second;
+          }
+
           LiveTab* restored_tab = context->AddRestoredTab(
               tab.navigations, context->GetTabCount(),
-              tab.current_navigation_index, tab.extension_app_id, tab.group,
+              tab.current_navigation_index, tab.extension_app_id, new_group,
               tab.group_visual_data.value_or(tab_groups::TabGroupVisualData()),
               static_cast<int>(tab_i) == window.selected_tab_index, tab.pinned,
               tab.platform_data.get(), tab.user_agent_override, nullptr);
@@ -369,7 +394,8 @@ std::vector<LiveTab*> TabRestoreServiceHelper::RestoreEntryById(
         }
 
         for (const auto& tab_group : window.tab_groups) {
-          context->SetVisualDataForGroup(tab_group.first, tab_group.second);
+          context->SetVisualDataForGroup(new_group_ids.at(tab_group.first),
+                                         tab_group.second);
         }
 
         // All the window's tabs had the same former browser_id.
-- 
2.20.1


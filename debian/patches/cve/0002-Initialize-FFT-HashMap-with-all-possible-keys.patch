From 5028b12d82355172b9f06f6a10adb14ea1e18b17 Mon Sep 17 00:00:00 2001
From: Artem Sumaneev <asumaneev@google.com>
Date: Tue, 22 Jun 2021 12:52:03 +0000
Subject: [PATCH 02/21] Initialize FFT HashMap with all possible keys

The HashMap that maps the FFT size to the setup data is initialized
with all of the valid FFT sizes with a nullptr for the setup data.
This means the keys of the HashMap never need to be updated; only the
setup data corresponding to the key needs updating.

M86 merge conflicts and resolution:
* third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
  fft_setups are Vector in M86, the fix is picked with
  crrev.com/c/2785204, which updates setups to HashMap.

(cherry picked from commit e34e28f6afc6844c95df347a19bca40496823979)

(cherry picked from commit 0d0066a85064140025c868cff05a4cf61aebb8c3)

Bug: 1212599
Change-Id: I60438e341f3b8f2a4512b3b0709fc99fb4119794
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2930542
Reviewed-by: Hongchan Choi <hongchan@chromium.org>
Commit-Queue: Raymond Toy <rtoy@chromium.org>
Cr-Original-Original-Commit-Position: refs/heads/master@{#888656}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2965677
Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Auto-Submit: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Hongchan Choi <hongchan@chromium.org>
Cr-Original-Commit-Position: refs/branch-heads/4472@{#1487}
Cr-Original-Branched-From: 3d60439cfb36485e76a1c5bb7f513d3721b20da1-refs/heads/master@{#870763}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2975761
Reviewed-by: Jana Grill <janagrill@google.com>
Reviewed-by: Victor-Gabriel Savu <vsavu@google.com>
Commit-Queue: Artem Sumaneev <asumaneev@google.com>
Owners-Override: Artem Sumaneev <asumaneev@google.com>
Cr-Commit-Position: refs/branch-heads/4240@{#1674}
Cr-Branched-From: f297677702651916bbf65e59c0d4bbd4ce57d1ee-refs/heads/master@{#800218}
---
 .../blink/renderer/platform/audio/fft_frame.h | 16 ++--
 .../platform/audio/pffft/fft_frame_pffft.cc   | 89 +++++++++++++------
 2 files changed, 72 insertions(+), 33 deletions(-)

diff --git a/third_party/blink/renderer/platform/audio/fft_frame.h b/third_party/blink/renderer/platform/audio/fft_frame.h
index 149b94c52..547459714 100644
--- a/third_party/blink/renderer/platform/audio/fft_frame.h
+++ b/third_party/blink/renderer/platform/audio/fft_frame.h
@@ -41,7 +41,7 @@
 #if defined(WTF_USE_WEBAUDIO_FFMPEG)
 struct RDFTContext;
 #elif defined(WTF_USE_WEBAUDIO_PFFFT)
-#include "third_party/blink/renderer/platform/wtf/vector.h"
+#include "third_party/blink/renderer/platform/wtf/hash_map.h"
 #include "third_party/pffft/src/pffft.h"
 #elif defined(OS_MAC)
 #include <Accelerate/Accelerate.h>
@@ -113,8 +113,14 @@ class PLATFORM_EXPORT FFTFrame {
                                       const FFTFrame& frame2,
                                       double x);
 
-  unsigned fft_size_;
-  unsigned log2fft_size_;
+  unsigned fft_size_ = 0;
+
+  // When using PFFFT, this slot is not irrelevant and not used because PFFFT
+  // supports sizes that aren't a power of 2.
+  // TODO(https://crbug.com/988121) Look into whether Mac vDSP really needs
+  // this.
+  unsigned log2fft_size_ = 0;
+
   // These two arrays contain the transformed data.  Instead of a single array
   // of complex numbers, we split the complex data into an array of the real
   // part and the imaginary part.
@@ -188,10 +194,10 @@ class PLATFORM_EXPORT FFTFrame {
     PFFFT_Setup* setup_;
   };
 
-  // Returns the vector that holds all of the possible FFTSetup objects.  This
+  // Returns the HashMap that holds all of the possible FFTSetup objects.  This
   // should be setup in the |Initialize()| method that is called when a context
   // is created.
-  static Vector<std::unique_ptr<FFTSetup>>& FFTSetups();
+  static HashMap<unsigned, std::unique_ptr<FFTSetup>>& FFTSetups();
 
   // Initialize an entry in FFTSetups for an FFT of order |fft_order|.  This can
   // be called from any thread, but if a new FFTSetup needs to be allocated,
diff --git a/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc b/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
index 620188fff..3317e8ad0 100644
--- a/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
+++ b/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
@@ -10,6 +10,7 @@
 #include "third_party/blink/renderer/platform/audio/hrtf_panner.h"
 #include "third_party/blink/renderer/platform/audio/vector_math.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
+#include "third_party/blink/renderer/platform/wtf/threading_primitives.h"
 #include "third_party/pffft/src/pffft.h"
 namespace blink {
 
@@ -38,45 +39,81 @@ FFTFrame::FFTSetup::~FFTSetup() {
   pffft_destroy_setup(setup_);
 }
 
-Vector<std::unique_ptr<FFTFrame::FFTSetup>>& FFTFrame::FFTSetups() {
+HashMap<unsigned, std::unique_ptr<FFTFrame::FFTSetup>>& FFTFrame::FFTSetups() {
   // TODO(rtoy): Let this bake for a bit and then remove the assertions after
   // we're confident the first call is from the main thread.
   static bool first_call = true;
 
+  // A HashMap to hold all of the possible FFT setups we need.  The setups are
+  // initialized lazily.  The key is the fft size, and the value is the setup
+  // data.
+  typedef HashMap<unsigned, std::unique_ptr<FFTSetup>> FFTHashMap_t;
+
+  DEFINE_THREAD_SAFE_STATIC_LOCAL(FFTHashMap_t, fft_setups, ());
+
   if (first_call) {
+    DEFINE_STATIC_LOCAL(Mutex, setup_lock, ());
+
     // Make sure we construct the fft_setups vector below on the main thread.
     // Once constructed, we can access it from any thread.
     DCHECK(IsMainThread());
     first_call = false;
-  }
 
-  // A vector to hold all of the possible FFT setups we need.  The setups are
-  // initialized lazily.
-  DEFINE_STATIC_LOCAL(Vector<std::unique_ptr<FFTSetup>>, fft_setups,
-                      (kMaxFFTPow2Size));
+    MutexLocker locker(setup_lock);
+
+    // Initialize the hash map with all the possible keys (FFT sizes), with a
+    // value of nullptr because we want to initialize the setup data lazily. The
+    // set of valid FFT sizes for PFFFT are of the form 2^k*3^m*5*n where k >=
+    // 5, m >= 0, n >= 0.  We only go up to a max size of 32768, because we need
+    // at least an FFT size of 32768 for the convolver node.
+
+    // TODO(crbug.com/988121):  Sync this with kMaxFFTPow2Size.
+    const int kMaxConvolverFFTSize = 32768;
+
+    for (int n = 1; n <= kMaxConvolverFFTSize; n *= 5) {
+      for (int m = 1; m <= kMaxConvolverFFTSize / n; m *= 3) {
+        for (int k = 32; k <= kMaxConvolverFFTSize / (n * m); k *= 2) {
+          int size = k * m * n;
+          if (size <= kMaxConvolverFFTSize && !fft_setups.Contains(size)) {
+            fft_setups.insert(size, nullptr);
+          }
+        }
+      }
+    }
+
+    // There should be 87 entries when we're done.
+    DCHECK_EQ(fft_setups.size(), 87u);
+  }
 
   return fft_setups;
 }
 
-void FFTFrame::InitializeFFTSetupForSize(wtf_size_t log2fft_size) {
+void FFTFrame::InitializeFFTSetupForSize(wtf_size_t fft_size) {
   auto& setup = FFTSetups();
 
-  if (!setup[log2fft_size]) {
+  DCHECK(setup.Contains(fft_size));
+
+  if (setup.find(fft_size)->value == nullptr) {
+    DEFINE_STATIC_LOCAL(Mutex, setup_lock, ());
+
     // Make sure allocation of a new setup only occurs on the main thread so we
     // don't have a race condition with multiple threads trying to write to the
     // same element of the vector.
     DCHECK(IsMainThread());
 
-    setup[log2fft_size] = std::make_unique<FFTSetup>(1 << log2fft_size);
+    auto fft_data = std::make_unique<FFTSetup>(fft_size);
+    MutexLocker locker(setup_lock);
+    setup.find(fft_size)->value = std::move(fft_data);
   }
 }
 
-PFFFT_Setup* FFTFrame::FFTSetupForSize(wtf_size_t log2fft_size) {
+PFFFT_Setup* FFTFrame::FFTSetupForSize(wtf_size_t fft_size) {
   auto& setup = FFTSetups();
 
-  DCHECK(setup[log2fft_size]);
+  DCHECK(setup.Contains(fft_size));
+  DCHECK(setup.find(fft_size)->value);
 
-  return setup[log2fft_size]->GetSetup();
+  return setup.find(fft_size)->value->GetSetup();
 }
 
 FFTFrame::FFTFrame(unsigned fft_size)
@@ -86,12 +123,10 @@ FFTFrame::FFTFrame(unsigned fft_size)
       imag_data_(fft_size / 2),
       complex_data_(fft_size),
       pffft_work_(fft_size) {
-  // We only allow power of two.
-  DCHECK_EQ(1UL << log2fft_size_, fft_size_);
 
   // Initialize the PFFFT_Setup object here so that it will be ready when we
   // compute FFTs.
-  InitializeFFTSetupForSize(log2fft_size_);
+  InitializeFFTSetupForSize(fft_size);
 }
 
 // Creates a blank/empty frame (interpolate() must later be called).
@@ -107,7 +142,7 @@ FFTFrame::FFTFrame(const FFTFrame& frame)
       pffft_work_(frame.fft_size_) {
   // Initialize the PFFFT_Setup object here wo that it will be ready when we
   // compute FFTs.
-  InitializeFFTSetupForSize(log2fft_size_);
+  InitializeFFTSetupForSize(fft_size_);
 
   // Copy/setup frame data.
   unsigned nbytes = sizeof(float) * (fft_size_ / 2);
@@ -134,21 +169,19 @@ void FFTFrame::Initialize(float sample_rate) {
   //
   // TODO(rtoy): Try to come up with some way so that |Initialize()| doesn't
   // need to know about how the HRTF panner uses FFTs.
-  unsigned hrtf_order = static_cast<unsigned>(
-      log2(HRTFPanner::FftSizeForSampleRate(sample_rate)));
+  unsigned hrtf_fft_size =
+      static_cast<unsigned>(HRTFPanner::FftSizeForSampleRate(sample_rate));
 
-  DCHECK_GT(hrtf_order, kMinFFTPow2Size);
-  DCHECK_LE(hrtf_order, kMaxFFTPow2Size);
+  DCHECK_GT(hrtf_fft_size, 1U << kMinFFTPow2Size);
+  DCHECK_LE(hrtf_fft_size, 1U << kMaxFFTPow2Size);
 
-  InitializeFFTSetupForSize(hrtf_order);
-  InitializeFFTSetupForSize(hrtf_order - 1);
+  InitializeFFTSetupForSize(hrtf_fft_size);
+  InitializeFFTSetupForSize(hrtf_fft_size / 2);
 }
 
 void FFTFrame::Cleanup() {
-  auto& setups = FFTSetups();
-
-  for (wtf_size_t k = 0; k < setups.size(); ++k) {
-    setups[k].reset();
+  for (auto& setup : FFTSetups()) {
+    setup.value.reset();
   }
 }
 
@@ -158,7 +191,7 @@ FFTFrame::~FFTFrame() {
 void FFTFrame::DoFFT(const float* data) {
   DCHECK_EQ(pffft_work_.size(), fft_size_);
 
-  PFFFT_Setup* setup = FFTSetupForSize(log2fft_size_);
+  PFFFT_Setup* setup = FFTSetupForSize(fft_size_);
   DCHECK(setup);
 
   pffft_transform_ordered(setup, data, complex_data_.Data(), pffft_work_.Data(),
@@ -195,7 +228,7 @@ void FFTFrame::DoInverseFFT(float* data) {
     fft_data[index + 1] = imag[k];
   }
 
-  PFFFT_Setup* setup = FFTSetupForSize(log2fft_size_);
+  PFFFT_Setup* setup = FFTSetupForSize(fft_size_);
   DCHECK(setup);
 
   pffft_transform_ordered(setup, fft_data, data, pffft_work_.Data(),
-- 
2.20.1


From 0bc49dc6482984ec140552aab83339f2d94ee6f6 Mon Sep 17 00:00:00 2001
From: Solomon Kinard <solomonkinard@chromium.org>
Date: Wed, 9 Jun 2021 15:54:57 +0000
Subject: [PATCH] Ensure tab strip is editable before editing

(cherry picked from commit 33109f1824b9ae3d488b7372f9aca68f611be606)

(cherry picked from commit f5ae8693fcb042797de12b6b9cc055da0090a80a)

Bug: 1198717,1197146,1197888,1196309,1202598
Change-Id: Ic51669a7f7b17a35cd2c0ed018abcfeddf068a26
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2891080
Commit-Queue: Solomon Kinard <solomonkinard@chromium.org>
Reviewed-by: Taylor Bergquist <tbergquist@chromium.org>
Reviewed-by: Karan Bhatia <karandeepb@chromium.org>
Cr-Original-Original-Commit-Position: refs/heads/master@{#883567}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2904568
Auto-Submit: Solomon Kinard <solomonkinard@chromium.org>
Cr-Original-Commit-Position: refs/branch-heads/4472@{#1169}
Cr-Original-Branched-From: 3d60439cfb36485e76a1c5bb7f513d3721b20da1-refs/heads/master@{#870763}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2944872
Reviewed-by: Achuith Bhandarkar <achuith@chromium.org>
Commit-Queue: Artem Sumaneev <asumaneev@google.com>
Owners-Override: Artem Sumaneev <asumaneev@google.com>
Cr-Commit-Position: refs/branch-heads/4430@{#1503}
Cr-Branched-From: e5ce7dc4f7518237b3d9bb93cccca35d25216cbe-refs/heads/master@{#857950}
---
 .../api/tab_groups/tab_groups_api.cc          |  30 +++--
 .../api/tab_groups/tab_groups_api_unittest.cc |  34 +++++-
 .../browser/extensions/api/tabs/tabs_api.cc   | 115 ++++++++++++++----
 .../extensions/api/tabs/tabs_api_unittest.cc  | 104 ++++++++++++++++
 .../extensions/api/tabs/tabs_constants.cc     |   5 +-
 .../extensions/api/tabs/tabs_constants.h      |   2 +-
 .../browser/extensions/extension_tab_util.cc  |  15 +++
 .../browser/extensions/extension_tab_util.h   |   8 ++
 chrome/test/base/test_browser_window.cc       |   6 +-
 chrome/test/base/test_browser_window.h        |   2 +
 10 files changed, 275 insertions(+), 46 deletions(-)

diff --git a/chrome/browser/extensions/api/tab_groups/tab_groups_api.cc b/chrome/browser/extensions/api/tab_groups/tab_groups_api.cc
index 2a6249782..a1079a10e 100644
--- a/chrome/browser/extensions/api/tab_groups/tab_groups_api.cc
+++ b/chrome/browser/extensions/api/tab_groups/tab_groups_api.cc
@@ -123,7 +123,10 @@ ExtensionFunction::ResponseAction TabGroupsQueryFunction::Run() {
       }
     }
 
-    TabStripModel* tab_strip = browser->tab_strip_model();
+    TabStripModel* tab_strip =
+        ExtensionTabUtil::GetEditableTabStripModel(browser);
+    if (!tab_strip)
+      return RespondNow(Error(tabs_constants::kTabStripNotEditableQueryError));
     for (const tab_groups::TabGroupId& id :
          tab_strip->group_model()->ListTabGroups()) {
       const tab_groups::TabGroupVisualData* visual_data =
@@ -184,8 +187,11 @@ ExtensionFunction::ResponseAction TabGroupsUpdateFunction::Run() {
   if (params->update_properties.title.get())
     title = base::UTF8ToUTF16(*params->update_properties.title);
 
-  TabGroup* tab_group =
-      browser->tab_strip_model()->group_model()->GetTabGroup(id);
+  TabStripModel* tab_strip_model =
+      ExtensionTabUtil::GetEditableTabStripModel(browser);
+  if (!tab_strip_model)
+    return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+  TabGroup* tab_group = tab_strip_model->group_model()->GetTabGroup(id);
 
   tab_groups::TabGroupVisualData new_visual_data(title, color, collapsed);
   tab_group->SetVisualData(std::move(new_visual_data));
@@ -232,12 +238,12 @@ bool TabGroupsMoveFunction::MoveGroup(int group_id,
     return false;
   }
 
-  if (!source_browser->window()->IsTabStripEditable()) {
+  TabStripModel* source_tab_strip =
+      ExtensionTabUtil::GetEditableTabStripModel(source_browser);
+  if (!source_tab_strip) {
     *error = tabs_constants::kTabStripNotEditableError;
     return false;
   }
-
-  TabStripModel* source_tab_strip = source_browser->tab_strip_model();
   gfx::Range tabs =
       source_tab_strip->group_model()->GetTabGroup(*group)->ListTabs();
   if (tabs.length() == 0)
@@ -252,11 +258,6 @@ bool TabGroupsMoveFunction::MoveGroup(int group_id,
       return false;
     }
 
-    if (!target_browser->window()->IsTabStripEditable()) {
-      *error = tabs_constants::kTabStripNotEditableError;
-      return false;
-    }
-
     // TODO(crbug.com/990158): Rather than calling is_type_normal(), should
     // this call SupportsWindowFeature(Browser::FEATURE_TABSTRIP)?
     if (!target_browser->is_type_normal()) {
@@ -271,7 +272,12 @@ bool TabGroupsMoveFunction::MoveGroup(int group_id,
 
     // If windowId is different from the current window, move between windows.
     if (target_browser != source_browser) {
-      TabStripModel* target_tab_strip = target_browser->tab_strip_model();
+      TabStripModel* target_tab_strip =
+          ExtensionTabUtil::GetEditableTabStripModel(target_browser);
+      if (!target_tab_strip) {
+        *error = tabs_constants::kTabStripNotEditableError;
+        return false;
+      }
 
       if (new_index > target_tab_strip->count() || new_index < 0)
         new_index = target_tab_strip->count();
diff --git a/chrome/browser/extensions/api/tab_groups/tab_groups_api_unittest.cc b/chrome/browser/extensions/api/tab_groups/tab_groups_api_unittest.cc
index efebc9b26..4934de996 100644
--- a/chrome/browser/extensions/api/tab_groups/tab_groups_api_unittest.cc
+++ b/chrome/browser/extensions/api/tab_groups/tab_groups_api_unittest.cc
@@ -17,6 +17,7 @@
 #include "chrome/browser/extensions/api/tab_groups/tab_groups_event_router.h"
 #include "chrome/browser/extensions/api/tab_groups/tab_groups_event_router_factory.h"
 #include "chrome/browser/extensions/api/tab_groups/tab_groups_util.h"
+#include "chrome/browser/extensions/api/tabs/tabs_constants.h"
 #include "chrome/browser/extensions/extension_function_test_utils.h"
 #include "chrome/browser/extensions/extension_service_test_base.h"
 #include "chrome/browser/extensions/extension_tab_util.h"
@@ -124,13 +125,12 @@ void TabGroupsApiUnitTest::SetUp() {
   InitializeEmptyExtensionService();
 
   // Create a browser window.
-  TestBrowserWindow* window = new TestBrowserWindow;
+  browser_window_ = std::make_unique<TestBrowserWindow>();
   // TestBrowserWindowOwner handles its own lifetime, and also cleans up
   // |window2|.
-  new TestBrowserWindowOwner(window);
   Browser::CreateParams params(profile(), /* user_gesture */ true);
   params.type = Browser::TYPE_NORMAL;
-  params.window = window;
+  params.window = browser_window_.get();
   browser_ = std::unique_ptr<Browser>(Browser::Create(params));
   BrowserList::SetLastActive(browser_.get());
 
@@ -545,4 +545,32 @@ TEST_F(TabGroupsApiUnitTest, TabGroupsOnMoved) {
                              api::tab_groups::OnMoved::kEventName));
 }
 
+// Test that tab groups aren't edited while dragging.
+TEST_F(TabGroupsApiUnitTest, IsTabStripEditable) {
+  scoped_refptr<const Extension> extension = CreateTabGroupsExtension();
+  int group_id = tab_groups_util::GetGroupId(
+      browser()->tab_strip_model()->AddToNewGroup({0}));
+  const std::string args =
+      base::StringPrintf(R"([%d, {"index": %d}])", group_id, 1);
+
+  // Succeed moving group in normal case.
+  {
+    auto function = base::MakeRefCounted<TabGroupsMoveFunction>();
+    function->set_extension(extension);
+    ASSERT_TRUE(extension_function_test_utils::RunFunction(
+        function.get(), args, browser(), api_test_utils::NONE));
+  }
+
+  // Gracefully cancel group tab drag if tab strip isn't editable.
+  {
+    browser_window()->SetIsTabStripEditable(false);
+    auto function = base::MakeRefCounted<TabGroupsMoveFunction>();
+    function->set_extension(extension);
+    std::string error =
+        extension_function_test_utils::RunFunctionAndReturnError(
+            function.get(), args, browser());
+    EXPECT_EQ(tabs_constants::kTabStripNotEditableError, error);
+  }
+}
+
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/tabs/tabs_api.cc b/chrome/browser/extensions/api/tabs/tabs_api.cc
index 6c34a459a..b4d08eef2 100644
--- a/chrome/browser/extensions/api/tabs/tabs_api.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_api.cc
@@ -308,7 +308,7 @@ int MoveTabToWindow(ExtensionFunction* function,
     return -1;
   }
 
-  if (!target_browser->window()->IsTabStripEditable()) {
+  if (!ExtensionTabUtil::IsTabStripEditable()) {
     *error = tabs_constants::kTabStripNotEditableError;
     return -1;
   }
@@ -333,7 +333,9 @@ int MoveTabToWindow(ExtensionFunction* function,
     return -1;
   }
 
-  TabStripModel* target_tab_strip = target_browser->tab_strip_model();
+  TabStripModel* target_tab_strip =
+      ExtensionTabUtil::GetEditableTabStripModel(target_browser);
+  DCHECK(target_tab_strip);
 
   // Clamp move location to the last position.
   // This is ">" because it can append to a new index position.
@@ -581,7 +583,7 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
       return RespondNow(Error(std::move(error)));
     }
 
-    if (!source_browser->window()->IsTabStripEditable())
+    if (!ExtensionTabUtil::IsTabStripEditable())
       return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
 
     if (source_browser->profile() != window_profile)
@@ -699,7 +701,10 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
       std::unique_ptr<content::WebContents> detached_tab =
           source_tab_strip->DetachWebContentsAt(tab_index);
       contents = detached_tab.get();
-      TabStripModel* target_tab_strip = new_window->tab_strip_model();
+      TabStripModel* target_tab_strip =
+          ExtensionTabUtil::GetEditableTabStripModel(new_window);
+      if (!target_tab_strip)
+        return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
       target_tab_strip->InsertWebContentsAt(
           urls.size(), std::move(detached_tab), TabStripModel::ADD_NONE);
     }
@@ -926,7 +931,10 @@ ExtensionFunction::ResponseAction TabsGetSelectedFunction::Run() {
   if (!GetBrowserFromWindowID(this, window_id, &browser, &error))
     return RespondNow(Error(std::move(error)));
 
-  TabStripModel* tab_strip = browser->tab_strip_model();
+  TabStripModel* tab_strip =
+      ExtensionTabUtil::GetEditableTabStripModel(browser);
+  if (!tab_strip)
+    return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
   WebContents* contents = tab_strip->GetActiveWebContents();
   if (!contents)
     return RespondNow(Error(tabs_constants::kNoSelectedTabError));
@@ -1043,7 +1051,12 @@ ExtensionFunction::ResponseAction TabsQueryFunction::Run() {
       continue;
     }
 
-    TabStripModel* tab_strip = browser->tab_strip_model();
+    // Bug fix for crbug.com/1197888. Disable query during any tab drag to
+    // ensure that the result matches the eventual state of the tab strip.
+    TabStripModel* tab_strip =
+        ExtensionTabUtil::GetEditableTabStripModel(browser);
+    if (!tab_strip)
+      return RespondNow(Error(tabs_constants::kTabStripNotEditableQueryError));
     for (int i = 0; i < tab_strip->count(); ++i) {
       WebContents* web_contents = tab_strip->GetWebContentsAt(i);
 
@@ -1193,6 +1206,9 @@ ExtensionFunction::ResponseAction TabsDuplicateFunction::Run() {
     return RespondNow(Error(std::move(error)));
   }
 
+  if (!ExtensionTabUtil::IsTabStripEditable())
+    return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+
   WebContents* new_contents = chrome::DuplicateTabAt(browser, tab_index);
   if (!has_callback())
     return RespondNow(NoArguments());
@@ -1227,6 +1243,9 @@ ExtensionFunction::ResponseAction TabsGetFunction::Run() {
     return RespondNow(Error(std::move(error)));
   }
 
+  if (!ExtensionTabUtil::IsTabStripEditable())
+    return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+
   return RespondNow(ArgumentList(tabs::Get::Results::Create(
       *CreateTabObjectHelper(contents, extension(), source_context_type(),
                              tab_strip, tab_index))));
@@ -1261,7 +1280,10 @@ ExtensionFunction::ResponseAction TabsHighlightFunction::Run() {
   if (!GetBrowserFromWindowID(this, window_id, &browser, &error))
     return RespondNow(Error(std::move(error)));
 
-  TabStripModel* tabstrip = browser->tab_strip_model();
+  // Don't let the extension update the tab if the user is dragging tabs.
+  TabStripModel* tabstrip = ExtensionTabUtil::GetEditableTabStripModel(browser);
+  if (!tabstrip)
+    return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
   ui::ListSelectionModel selection;
   int active_index = -1;
 
@@ -1287,7 +1309,11 @@ ExtensionFunction::ResponseAction TabsHighlightFunction::Run() {
     return RespondNow(Error(tabs_constants::kNoHighlightedTabError));
 
   selection.set_active(active_index);
-  browser->tab_strip_model()->SetSelectionFromModel(std::move(selection));
+  TabStripModel* tab_strip_model =
+      ExtensionTabUtil::GetEditableTabStripModel(browser);
+  if (!tab_strip_model)
+    return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+  tab_strip_model->SetSelectionFromModel(std::move(selection));
   return RespondNow(OneArgument(base::Value::FromUniquePtrValue(
       ExtensionTabUtil::CreateWindowValueForExtension(
           *browser, extension(), ExtensionTabUtil::kPopulateTabs,
@@ -1299,13 +1325,6 @@ bool TabsHighlightFunction::HighlightTab(TabStripModel* tabstrip,
                                          int* active_index,
                                          int index,
                                          std::string* error) {
-  // Cannot change tab highlight. This may for instance be due to user dragging
-  // in progress.
-  if (!tabstrip->delegate()->CanHighlightTabs()) {
-    *error = tabs_constants::kCannotHighlightTabs;
-    return false;
-  }
-
   // Make sure the index is in range.
   if (!tabstrip->ContainsIndex(index)) {
     *error = ErrorUtils::FormatErrorMessage(
@@ -1334,7 +1353,11 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
     Browser* browser = ChromeExtensionFunctionDetails(this).GetCurrentBrowser();
     if (!browser)
       return RespondNow(Error(tabs_constants::kNoCurrentWindowError));
-    contents = browser->tab_strip_model()->GetActiveWebContents();
+    TabStripModel* tab_strip_model =
+        ExtensionTabUtil::GetEditableTabStripModel(browser);
+    if (!tab_strip_model)
+      return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+    contents = tab_strip_model->GetActiveWebContents();
     if (!contents)
       return RespondNow(Error(tabs_constants::kNoSelectedTabError));
     tab_id = sessions::SessionTabHelper::IdForTab(contents).id();
@@ -1383,6 +1406,11 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
     active = *params->update_properties.active;
 
   if (active) {
+    // Bug fix for crbug.com/1197888. Don't let the extension update the tab if
+    // the user is dragging tabs.
+    if (!ExtensionTabUtil::IsTabStripEditable())
+      return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+
     if (tab_strip->active_index() != tab_index) {
       tab_strip->ActivateTabAt(tab_index);
       DCHECK_EQ(contents, tab_strip->GetActiveWebContents());
@@ -1390,14 +1418,23 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
   }
 
   if (params->update_properties.highlighted.get()) {
+    // Bug fix for crbug.com/1197888. Don't let the extension update the tab if
+    // the user is dragging tabs.
+    if (!ExtensionTabUtil::IsTabStripEditable())
+      return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+
     bool highlighted = *params->update_properties.highlighted;
     if (highlighted != tab_strip->IsTabSelected(tab_index)) {
-      if (!tab_strip->ToggleSelectionAt(tab_index))
-        return RespondNow(Error(tabs_constants::kCannotHighlightTabs));
+      tab_strip->ToggleSelectionAt(tab_index);
     }
   }
 
   if (params->update_properties.pinned.get()) {
+    // Bug fix for crbug.com/1197888. Don't let the extension update the tab if
+    // the user is dragging tabs.
+    if (!ExtensionTabUtil::IsTabStripEditable())
+      return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+
     bool pinned = *params->update_properties.pinned;
     tab_strip->SetTabPinned(tab_index, pinned);
 
@@ -1425,6 +1462,11 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
           tabs_constants::kTabNotFoundError, base::NumberToString(opener_id))));
     }
 
+    // Bug fix for crbug.com/1197888. Don't let the extension update the tab if
+    // the user is dragging tabs.
+    if (!ExtensionTabUtil::IsTabStripEditable())
+      return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+
     if (tab_strip->GetIndexOfWebContents(opener_contents) ==
         TabStripModel::kNoTab) {
       return RespondNow(
@@ -1569,7 +1611,7 @@ bool TabsMoveFunction::MoveTab(int tab_id,
   }
 
   // Don't let the extension move the tab if the user is dragging tabs.
-  if (!source_browser->window()->IsTabStripEditable()) {
+  if (!ExtensionTabUtil::IsTabStripEditable()) {
     *error = tabs_constants::kTabStripNotEditableError;
     return false;
   }
@@ -1587,11 +1629,15 @@ bool TabsMoveFunction::MoveTab(int tab_id,
     *new_index = inserted_index;
 
     if (has_callback()) {
+      TabStripModel* tab_strip_model =
+          ExtensionTabUtil::GetEditableTabStripModel(target_browser);
+      DCHECK(tab_strip_model);
       content::WebContents* web_contents =
-          target_browser->tab_strip_model()->GetWebContentsAt(inserted_index);
-      tab_values->Append(CreateTabObjectHelper(
-                             web_contents, extension(), source_context_type(),
-                             target_browser->tab_strip_model(), inserted_index)
+          tab_strip_model->GetWebContentsAt(inserted_index);
+
+      tab_values->Append(CreateTabObjectHelper(web_contents, extension(),
+                                               source_context_type(),
+                                               tab_strip_model, inserted_index)
                              ->ToValue());
     }
 
@@ -1796,6 +1842,10 @@ ExtensionFunction::ResponseAction TabsGroupFunction::Run() {
       return RespondNow(Error(std::move(error)));
   }
 
+  DCHECK(target_browser);
+  if (!target_browser->window()->IsTabStripEditable())
+    return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+
   // Get all tab IDs from parameters.
   std::vector<int> tab_ids;
   if (params->options.tab_ids.as_integers) {
@@ -1848,7 +1898,10 @@ ExtensionFunction::ResponseAction TabsGroupFunction::Run() {
 
   // Get the remaining group metadata and add the tabs to the group.
   // At this point, we assume this is a valid action due to the checks above.
-  TabStripModel* tab_strip = target_browser->tab_strip_model();
+  TabStripModel* tab_strip =
+      ExtensionTabUtil::GetEditableTabStripModel(target_browser);
+  if (!tab_strip)
+    return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
   if (group.is_empty()) {
     group = tab_strip->AddToNewGroup(tab_indices);
     group_id = tab_groups_util::GetGroupId(group);
@@ -1927,7 +1980,13 @@ WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
   if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
     return nullptr;
 
-  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
+  TabStripModel* tab_strip_model =
+      ExtensionTabUtil::GetEditableTabStripModel(browser);
+  if (!tab_strip_model) {
+    *error = tabs_constants::kTabStripNotEditableError;
+    return nullptr;
+  }
+  WebContents* contents = tab_strip_model->GetActiveWebContents();
   if (!contents) {
     *error = "No active web contents to capture";
     return nullptr;
@@ -2044,7 +2103,11 @@ ExtensionFunction::ResponseAction TabsDetectLanguageFunction::Run() {
     browser = ChromeExtensionFunctionDetails(this).GetCurrentBrowser();
     if (!browser)
       return RespondNow(Error(tabs_constants::kNoCurrentWindowError));
-    contents = browser->tab_strip_model()->GetActiveWebContents();
+    TabStripModel* tab_strip_model =
+        ExtensionTabUtil::GetEditableTabStripModel(browser);
+    if (!tab_strip_model)
+      return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+    contents = tab_strip_model->GetActiveWebContents();
     if (!contents)
       return RespondNow(Error(tabs_constants::kNoSelectedTabError));
   }
diff --git a/chrome/browser/extensions/api/tabs/tabs_api_unittest.cc b/chrome/browser/extensions/api/tabs/tabs_api_unittest.cc
index 65b6e93ee..ca3a39544 100644
--- a/chrome/browser/extensions/api/tabs/tabs_api_unittest.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_api_unittest.cc
@@ -131,6 +131,110 @@ void TabsApiUnitTest::TearDown() {
   ExtensionServiceTestBase::TearDown();
 }
 
+// Bug fix for crbug.com/1196309. Ensure that an extension can't update the tab
+// strip while a tab drag is in progress.
+TEST_F(TabsApiUnitTest, IsTabStripEditable) {
+  // Add a couple of web contents to the browser and get their tab IDs.
+  constexpr int kNumTabs = 2;
+  std::vector<int> tab_ids;
+  std::vector<content::WebContents*> web_contentses;
+  for (int i = 0; i < kNumTabs; ++i) {
+    std::unique_ptr<content::WebContents> contents(
+        content::WebContentsTester::CreateTestWebContents(profile(), nullptr));
+    CreateSessionServiceTabHelper(contents.get());
+    tab_ids.push_back(
+        sessions::SessionTabHelper::IdForTab(contents.get()).id());
+    web_contentses.push_back(contents.get());
+    browser()->tab_strip_model()->AppendWebContents(std::move(contents),
+                                                    /* foreground */ true);
+  }
+  ASSERT_EQ(kNumTabs, browser()->tab_strip_model()->count());
+
+  ASSERT_TRUE(browser_window()->IsTabStripEditable());
+  auto extension = CreateTabsExtension();
+
+  // Succeed while tab drag not in progress.
+  {
+    std::string args = base::StringPrintf("[{\"tabs\": [%d]}]", 0);
+    scoped_refptr<TabsHighlightFunction> function =
+        base::MakeRefCounted<TabsHighlightFunction>();
+    function->set_extension(extension);
+    ASSERT_TRUE(extension_function_test_utils::RunFunction(
+        function.get(), args, browser(), api_test_utils::NONE));
+  }
+
+  browser_window()->SetIsTabStripEditable(false);
+  ASSERT_FALSE(browser_window()->IsTabStripEditable());
+
+  // Succeed with updates that don't interact with the tab strip model.
+  {
+    const char* url = "https://example.com/";
+    std::string args =
+        base::StringPrintf("[%d, {\"url\": \"%s\"}]", tab_ids[0], url);
+    scoped_refptr<TabsUpdateFunction> function =
+        base::MakeRefCounted<TabsUpdateFunction>();
+    function->set_extension(extension);
+    std::unique_ptr<base::Value> value(
+        extension_function_test_utils::RunFunctionAndReturnSingleResult(
+            function.get(), args, browser(), api_test_utils::NONE));
+    EXPECT_TRUE(value && value->is_dict());
+    EXPECT_EQ(*value->FindStringKey("pendingUrl"), url);
+  }
+
+  // Bug fix for crbug.com/1198717. Error updating tabs while drag in progress.
+  {
+    std::string args =
+        base::StringPrintf("[%d, {\"highlighted\": true}]", tab_ids[0]);
+    auto function = base::MakeRefCounted<TabsUpdateFunction>();
+    function->set_extension(extension);
+    std::string error =
+        extension_function_test_utils::RunFunctionAndReturnError(
+            function.get(), args, browser());
+    EXPECT_EQ(tabs_constants::kTabStripNotEditableError, error);
+  }
+
+  // Error highlighting tab while drag in progress.
+  {
+    std::string args = base::StringPrintf("[{\"tabs\": [%d]}]", tab_ids[0]);
+    auto function = base::MakeRefCounted<TabsHighlightFunction>();
+    function->set_extension(extension);
+    std::string error =
+        extension_function_test_utils::RunFunctionAndReturnError(
+            function.get(), args, browser(), api_test_utils::NONE);
+    EXPECT_EQ(tabs_constants::kTabStripNotEditableError, error);
+  }
+
+  // Bug fix for crbug.com/1197146. Tab group modification during drag.
+  {
+    std::string args = base::StringPrintf("[{\"tabIds\": [%d]}]", tab_ids[0]);
+    scoped_refptr<TabsGroupFunction> function =
+        base::MakeRefCounted<TabsGroupFunction>();
+    function->set_extension(extension);
+    std::string error =
+        extension_function_test_utils::RunFunctionAndReturnError(
+            function.get(), args, browser());
+    EXPECT_EQ(tabs_constants::kTabStripNotEditableError, error);
+  }
+
+  // Bug fix for crbug.com/1197888. Disable query during any tab drag to ensure
+  // that the result matches the eventual state of the tab strip.
+  {
+    const char* args = "[{}]";
+    scoped_refptr<TabsQueryFunction> function =
+        base::MakeRefCounted<TabsQueryFunction>();
+    function->set_extension(extension);
+    std::string error =
+        extension_function_test_utils::RunFunctionAndReturnError(
+            function.get(), args, browser());
+    EXPECT_EQ(tabs_constants::kTabStripNotEditableQueryError, error);
+  }
+
+  // TODO(solomonkinard): Consider adding tests for drag cancellation.
+
+  while (!browser()->tab_strip_model()->empty())
+    browser()->tab_strip_model()->DetachWebContentsAt(0);
+}
+
 TEST_F(TabsApiUnitTest, QueryWithoutTabsPermission) {
   GURL tab_urls[] = {GURL("http://www.google.com"),
                      GURL("http://www.example.com"),
diff --git a/chrome/browser/extensions/api/tabs/tabs_constants.cc b/chrome/browser/extensions/api/tabs/tabs_constants.cc
index 8bd3d4edf..e438ed25f 100644
--- a/chrome/browser/extensions/api/tabs/tabs_constants.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_constants.cc
@@ -92,6 +92,8 @@ const char kCannotDiscardTab[] = "Cannot discard tab with id: *.";
 const char kCannotFindTabToDiscard[] = "Cannot find a tab to discard.";
 const char kTabStripNotEditableError[] =
     "Tabs cannot be edited right now (user may be dragging a tab).";
+const char kTabStripNotEditableQueryError[] =
+    "Tabs cannot be queried right now (user may be dragging a tab).";
 const char kNoSelectedTabError[] = "No selected tab";
 const char kNoHighlightedTabError[] = "No highlighted tab";
 const char kIncognitoModeIsDisabled[] = "Incognito mode is disabled.";
@@ -124,9 +126,6 @@ const char kGroupParamsError[] =
 const char kCannotNavigateToDevtools[] =
     "Cannot navigate to a devtools:// page without either the devtools or "
     "debugger permission.";
-const char kCannotHighlightTabs[] =
-    "Cannot change tab highlight. This may for instance be due to user "
-    "dragging in progress.";
 
 }  // namespace tabs_constants
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/tabs/tabs_constants.h b/chrome/browser/extensions/api/tabs/tabs_constants.h
index 7278abcda..3e257f524 100644
--- a/chrome/browser/extensions/api/tabs/tabs_constants.h
+++ b/chrome/browser/extensions/api/tabs/tabs_constants.h
@@ -91,6 +91,7 @@ extern const char kTabNotFoundError[];
 extern const char kCannotDiscardTab[];
 extern const char kCannotFindTabToDiscard[];
 extern const char kTabStripNotEditableError[];
+extern const char kTabStripNotEditableQueryError[];
 extern const char kNoHighlightedTabError[];
 extern const char kNoSelectedTabError[];
 extern const char kIncognitoModeIsDisabled[];
@@ -110,7 +111,6 @@ extern const char kBrowserWindowNotAllowed[];
 extern const char kLockedFullscreenModeNewTabError[];
 extern const char kGroupParamsError[];
 extern const char kCannotNavigateToDevtools[];
-extern const char kCannotHighlightTabs[];
 
 }  // namespace tabs_constants
 }  // namespace extensions
diff --git a/chrome/browser/extensions/extension_tab_util.cc b/chrome/browser/extensions/extension_tab_util.cc
index 3622b811f..d2282840d 100644
--- a/chrome/browser/extensions/extension_tab_util.cc
+++ b/chrome/browser/extensions/extension_tab_util.cc
@@ -971,4 +971,19 @@ api::tabs::TabStatus ExtensionTabUtil::GetLoadingStatus(WebContents* contents) {
   return api::tabs::TAB_STATUS_COMPLETE;
 }
 
+// static
+bool ExtensionTabUtil::IsTabStripEditable() {
+  for (auto* browser : *BrowserList::GetInstance())
+    if (browser && !browser->window()->IsTabStripEditable())
+      return false;
+  return true;
+}
+
+// static
+TabStripModel* ExtensionTabUtil::GetEditableTabStripModel(Browser* browser) {
+  if (!IsTabStripEditable())
+    return nullptr;
+  return browser->tab_strip_model();
+}
+
 }  // namespace extensions
diff --git a/chrome/browser/extensions/extension_tab_util.h b/chrome/browser/extensions/extension_tab_util.h
index d2a8faaa0..5798e3c89 100644
--- a/chrome/browser/extensions/extension_tab_util.h
+++ b/chrome/browser/extensions/extension_tab_util.h
@@ -253,6 +253,14 @@ class ExtensionTabUtil {
   // some non-const member functions of |contents|, but actually leaves it
   // unmodified.
   static api::tabs::TabStatus GetLoadingStatus(content::WebContents* contents);
+
+  // Check TabStripModel editability in every browser because a drag session
+  // could be running in another browser that reverts to the current browser. Or
+  // a drag could be mid-handoff if from one browser to another.
+  static bool IsTabStripEditable();
+
+  // Retrieve a TabStripModel only if every browser is editable.
+  static TabStripModel* GetEditableTabStripModel(Browser* browser);
 };
 
 }  // namespace extensions
diff --git a/chrome/test/base/test_browser_window.cc b/chrome/test/base/test_browser_window.cc
index eec5ab452..5d382d2a7 100644
--- a/chrome/test/base/test_browser_window.cc
+++ b/chrome/test/base/test_browser_window.cc
@@ -181,7 +181,11 @@ bool TestBrowserWindow::IsBookmarkBarAnimating() const {
 }
 
 bool TestBrowserWindow::IsTabStripEditable() const {
-  return true;
+  return is_tab_strip_editable_;
+}
+
+void TestBrowserWindow::SetIsTabStripEditable(bool is_editable) {
+  is_tab_strip_editable_ = is_editable;
 }
 
 bool TestBrowserWindow::IsToolbarVisible() const {
diff --git a/chrome/test/base/test_browser_window.h b/chrome/test/base/test_browser_window.h
index 4f50ecda5..dd4365b57 100644
--- a/chrome/test/base/test_browser_window.h
+++ b/chrome/test/base/test_browser_window.h
@@ -124,6 +124,7 @@ class TestBrowserWindow : public BrowserWindow {
   bool IsBookmarkBarVisible() const override;
   bool IsBookmarkBarAnimating() const override;
   bool IsTabStripEditable() const override;
+  void SetIsTabStripEditable(bool is_editable);
   bool IsToolbarVisible() const override;
   bool IsToolbarShowing() const override;
   SharingDialog* ShowSharingDialog(content::WebContents* contents,
@@ -248,6 +249,7 @@ class TestBrowserWindow : public BrowserWindow {
 
   std::string workspace_;
   bool visible_on_all_workspaces_ = false;
+  bool is_tab_strip_editable_ = true;
 
   std::unique_ptr<FeaturePromoController> feature_promo_controller_;
 
-- 
2.20.1

